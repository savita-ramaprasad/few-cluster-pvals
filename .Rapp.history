reg_with_dummies <- function(data, y){#
	# getting rid of the intercept#
	return(glm(y ~ 0+ independent_variable + post + treat  + sex.dummy +  educ.dummy1 + educ.dummy2 + educ.dummy3 + m_agegrp.dummy1 + m_agegrp.dummy2 + treat_rec + rec15 + rec34 + rec36 + frstbrn.dummy + marital2.dummy + raceethk.dummy1 + raceethk.dummy2 + raceethk.dummy3 + year.dummy1 + year.dummy2 + year.dummy3 + year.dummy4 + year.dummy5 + year.dummy6 + year.dummy7 + year.dummy8 + year.dummy9 + year.dummy10 + year.dummy11 + year.dummy12 + year.dummy13  + state.dummy1 + state.dummy2 + state.dummy3 + CHILDNM + INCPORAT , data = data))#
}
a <- reg_with_dummies(tdi_states, tdi_states$P_NUMROT)
significance_wild(a, tdi_states, 5 )
hep <- glm(P_NUMROT ~ 0+ independent_variable + post + treat  + sex.dummy +  educ.dummy1 + educ.dummy2 + educ.dummy3 + m_agegrp.dummy1 + m_agegrp.dummy2 + treat_rec + rec15 + rec34 + rec36 + frstbrn.dummy + marital2.dummy + raceethk.dummy1 + raceethk.dummy2 + raceethk.dummy3 + year.dummy1 + year.dummy2 + year.dummy3 + year.dummy4 + year.dummy5 + year.dummy6 + year.dummy7 + year.dummy8 + year.dummy9 + year.dummy10 + year.dummy11 + year.dummy12 + year.dummy13  + state.dummy1 + state.dummy2 + state.dummy3 + CHILDNM + INCPORAT , data = tdi_states)
hep
significance_wild(hep, tdi_states, 5 )
reg_with_dummies <- function(data, y){#
	# getting rid of the intercept#
	return(glm(y ~ 0+ independent_variable + post + treat  + sex.dummy +  educ.dummy1 + educ.dummy2 + educ.dummy3 + m_agegrp.dummy1 + m_agegrp.dummy2 + treat_rec + rec15 + rec34 + rec36 + frstbrn.dummy + marital2.dummy + raceethk.dummy1 + raceethk.dummy2 + raceethk.dummy3 + year.dummy1 + year.dummy2 + year.dummy3 + year.dummy4 + year.dummy5 + year.dummy6 + year.dummy7 + year.dummy8 + year.dummy9 + year.dummy10 + year.dummy11 + year.dummy12 + year.dummy13  + state.dummy1 + state.dummy2 + state.dummy3 + CHILDNM + INCPORAT , data = data))#
}
a <- reg_with_dummies(tdi_states, tdi_states$P_NUMROT)
significance_wild(a, tdi_states, 5 )
dummy_reg <- function(data, y){#
	# getting rid of the intercept#
	a <- glm(y ~ 0+ independent_variable + post + treat  + sex.dummy +  educ.dummy1 + educ.dummy2 + educ.dummy3 + m_agegrp.dummy1 + m_agegrp.dummy2 + treat_rec + rec15 + rec34 + rec36 + frstbrn.dummy + marital2.dummy + raceethk.dummy1 + raceethk.dummy2 + raceethk.dummy3 + year.dummy1 + year.dummy2 + year.dummy3 + year.dummy4 + year.dummy5 + year.dummy6 + year.dummy7 + year.dummy8 + year.dummy9 + year.dummy10 + year.dummy11 + year.dummy12 + year.dummy13  + state.dummy1 + state.dummy2 + state.dummy3 + CHILDNM + INCPORAT , data = data))#
	return(a)#
}
dummy_reg <- function(data, y){#
	# getting rid of the intercept#
	a <- glm(y ~ 0+ independent_variable + post + treat  + sex.dummy +  educ.dummy1 + educ.dummy2 + educ.dummy3 + m_agegrp.dummy1 + m_agegrp.dummy2 + treat_rec + rec15 + rec34 + rec36 + frstbrn.dummy + marital2.dummy + raceethk.dummy1 + raceethk.dummy2 + raceethk.dummy3 + year.dummy1 + year.dummy2 + year.dummy3 + year.dummy4 + year.dummy5 + year.dummy6 + year.dummy7 + year.dummy8 + year.dummy9 + year.dummy10 + year.dummy11 + year.dummy12 + year.dummy13  + state.dummy1 + state.dummy2 + state.dummy3 + CHILDNM + INCPORAT , data = data))#
return(a)#
}
dummy_reg <- function(data, y){#
	# getting rid of the intercept#
	a <- glm(y ~ 0+ independent_variable + post + treat  + sex.dummy +  educ.dummy1 + educ.dummy2 + educ.dummy3 + m_agegrp.dummy1 + m_agegrp.dummy2 + treat_rec + rec15 + rec34 + rec36 + frstbrn.dummy + marital2.dummy + raceethk.dummy1 + raceethk.dummy2 + raceethk.dummy3 + year.dummy1 + year.dummy2 + year.dummy3 + year.dummy4 + year.dummy5 + year.dummy6 + year.dummy7 + year.dummy8 + year.dummy9 + year.dummy10 + year.dummy11 + year.dummy12 + year.dummy13  + state.dummy1 + state.dummy2 + state.dummy3 + CHILDNM + INCPORAT , data = data)#
return(a)#
}
a <- dummy_reg(tdi_states, tdi_states$P_NUMROT)
significance_wild(a, tdi_states, 5 )
library("devtools")
library("roxygen2")
setwd("~/my.pkg/")
document()
person(“Savita”, “Ramaprasad”, email = “savita.tungu@gmail.com", role = c("aut", "cre"))
person(“Savita”, “Ramaprasad”)
person( “Ramaprasad”)
person()
person("Savita")
person("Savita", "Rama")
person("Savita", "Ramaprasad")
person("Savita", "Ramaprasad", email = "savita.tungu@gmail.com")
person("Savita", "Ramaprasad", email = "savita.tungu@gmail.com", role = c("aut", "cre"))
document()
install("my.pkg")
setwd("..")
install("my.pkg")
cluster.wild.plm
library("clusterSEs")
cluster.wild.plm
cluster.wild.ivreg
cluster.wild.plm
conversion_data <- read.csv("~/Downloads/conversion_data.csv")
head(conversion_data, 3)
str(corr(conversion_data[, c(2,3,5,6)]))
str(cor(conversion_data[, c(2,3,5,6)]))
cor(conversion_data[, c(2,3,5,6)])
range(conversion_data$age)
mean(conversion_data$age)
dim(conversion_data)
mean(conversion_data$converted)
min(conversion_data$total_pages_visited)
mean(conversion_data[conversion_data$source == "Seo", ]$converted)
mean(conversion_data[conversion_data$source == "Ads", ]$converted)
mean(conversion_data[conversion_data$source == "Direct", ]$converted)
nrow(conversion_data)
training_conversion_data <- conversion_data[nrow(conversion_data) ,]
dim(training_conversion_data)
training_conversion_data <- conversion_data[1:nrow(conversion_data) ,]
training_conversion_data <- conversion_data[1:nrow(conversion_data) ,]
dim(training_conversion_data)
training_conversion_data <- conversion_data[1:nrow(conversion_data)/2 ,]
dim(training_conversion_data)
training_conversion_data <- conversion_data[1:(nrow(conversion_data))/2 ,]
dim(training_conversion_data)
nrow(conversion_data)/2
training_conversion_data <- conversion_data[(1:nrow(conversion_data)/2) ,]
dim(training_conversion_data)
training_conversion_data <- conversion_data[1,]
dim(training_conversion_data)
training_conversion_data <- conversion_data[1:3,]
dim(training_conversion_data)
nrow(conversion_Data)
nrow(conversion_data)
training_conversion_data <- conversion_data[1:nrow(conversion_data)/2, ]
nrow(training_conversion_data)
dim(training_conversion_data)
training_conversion_data <- conversion_data[c(1:nrow(conversion_data)/2), ]
dim(training_conversion_data)
half_rows <- nrow(conversion_data)
half_rows
half_rows <- nrow(conversion_data)/2
half_rows
training_conversion_data <- conversion_data[1:(nrow(conversion_data)/2), ]
dim(training_conversion_data)
training_rows <- sample(1:nrow(conversion_data), nrow(conversion_data)/2)))
training_rows <- sample(1:nrow(conversion_data), nrow(conversion_data)/2))
training_rows <- sample(1:nrow(conversion_data), nrow(conversion_data)/2)
head(training_rows, 20)
training_conversion_data <- conversion_data[1:(training_rows), ]
training_conversion_data <- conversion_data[1:training_rows, ]
training_conversion_data <- conversion_data[training_rows, ]
dim(training_conversion_data)
logit.model <- glm( converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country) ,family = binomial(link = "logit"), data = training_conversion_data)
summary(logit.model)
unique(conversion_data$country)
logit.model <- glm( converted ~ age  + factor(new_user) + total_pages_visited + factor(country) ,family = binomial(link = "logit"), data = training_conversion_data)
summary(logit.model)
library("devtools")
library("roxygen2")
setwd("~/my.pkg/")
check()
document()
document()
document()
document()
#' @export#
#' Calculate Cluster-Robust p-Values and Confidence Intervals Based on Webb (2013)#
#' @keywords cluster #
#
cluster.webb.plm <- function (mod, dat, cluster, ci.level = 0.95, boot.reps = 1000, #
    report = TRUE, prog.bar = TRUE, output.replicates = FALSE) #
{#
    if (min(class(dat) != "pdata.frame")) {#
        cat("\n", "\n", "Note: auto-converting data to pdata.frame; first two variables MUST be group and time indices.", #
            "\n", "See ?pdata.frame and consider manually converting data to pdata.frame.", #
            "\n", "\n")#
        dat <- pdata.frame(dat, index = colnames(dat)[1:2], row.names = F)#
    }#
    if (cluster == "group") {#
        clust <- attr(mod$mod, "index")[, 1]#
        clust.name <- colnames(attr(mod$mod, "index"))[1]#
        clust.full <- attr(dat, "index")[, 1]#
        used.idx <- which(rownames(dat) %in% rownames(mod$model))#
        G <- length(unique(clust))#
    }#
    if (cluster == "time") {#
        cat("\n", "\n", "Note: create new variable containing lag when clustering on time", #
            "\n")#
        clust <- attr(mod$mod, "index")[, 2]#
        clust.name <- colnames(attr(mod$mod, "index"))[2]#
        clust.full <- attr(dat, "index")[, 2]#
        used.idx <- which(rownames(dat) %in% rownames(mod$model))#
        G <- length(unique(clust))#
    }#
    if (cluster != "group" & cluster != "time") {#
        stop("invalid clustering variable; see help file")#
    }#
    form <- mod$formula#
    variables <- all.vars(form)#
    ind.variables <- names(coefficients(mod))#
    ind.variables.data <- all.vars(update(form, 1 ~ .))#
    se.clust <- sqrt(diag(vcovHC(mod, cluster = cluster)))#
    beta.mod <- coefficients(mod)[ind.variables]#
    w <- beta.mod/se.clust#
    dat$dv.new[used.idx] <- mod$model[, 1]#
    form.new <- update(form, dv.new ~ .)#
    if (prog.bar == TRUE) {#
        cat("Wild Cluster bootstrapping w/o imposing null...", #
            "\n")#
    }#
    boot.dat <- dat#
    w.store <- matrix(data = NA, nrow = boot.reps, ncol = length(ind.variables))#
    rep.store <- matrix(data = NA, nrow = boot.reps, ncol = length(beta.mod))#
    colnames(rep.store) <- ind.variables#
    resid <- residuals(mod)#
    if (prog.bar == TRUE) {#
        pb <- txtProgressBar(min = 0, max = boot.reps, initial = 0, #
            style = 3)#
    }#
    for (i in 1:boot.reps) {#
        if (prog.bar == TRUE) {#
            setTxtProgressBar(pb, value = i)#
        }#
        weight <- sample(c(-sqrt(1.5), -1, -sqrt(0.5), sqrt(0.5), 1, sqrt(1.5)),  #
            size = G, replace = T, prob = rep(1/6, 6))[match(clust, unique(clust))]#
        pseudo.resid <- resid * weight#
        pseudo.dv <- predict(mod) + pseudo.resid#
        boot.dat[used.idx, "dv.new"] <- pseudo.dv#
        boot.mod.call <- mod$call#
        boot.mod.call[[2]] <- quote(form.new)#
        boot.mod.call[[3]] <- quote(boot.dat)#
        boot.mod <- suppressWarnings(tryCatch(eval(boot.mod.call), #
            error = function(e) {#
                return(NA)#
            }))#
        se.boot <- sqrt(diag(vcovHC(boot.mod, cluster = cluster)))#
        beta.boot <- coefficients(boot.mod)[ind.variables]#
        w.store[i, ] <- (beta.boot - beta.mod)/se.boot#
        rep.store[i, ] <- beta.boot#
    }#
    if (prog.bar == TRUE) {#
        close(pb)#
    }#
    comp.fun <- function(vec2, vec1) {#
        as.numeric(vec1 > vec2)#
    }#
    if (length(ind.variables) == 1) {#
        p.store.s <- matrix(as.double(abs(w)) > as.double(abs(w.store)), #
            ncol = 1)#
        crit.t <- quantile(abs(w.store), ci.level)#
    }#
    else {#
        p.store.s <- t(apply(X = abs(w.store), FUN = comp.fun, #
            MARGIN = 1, vec1 = abs(w)))#
        crit.t <- apply(X = abs(w.store), MARGIN = 2, FUN = quantile, #
            probs = ci.level)#
    }#
    p.store <- 1 - (colSums(p.store.s)/boot.reps)#
    ci.lo <- beta.mod - crit.t * se.clust#
    ci.hi <- beta.mod + crit.t * se.clust#
    print.ci <- cbind(ind.variables, ci.lo, ci.hi)#
    print.ci <- rbind(c("variable name", "CI lower", "CI higher"), #
        print.ci)#
    out.ci <- cbind(ci.lo, ci.hi)#
    rownames(out.ci) <- ind.variables#
    colnames(out.ci) <- c("CI lower", "CI higher")#
    out <- matrix(p.store, ncol = 1)#
    colnames(out) <- c("wild cluster BS p-value")#
    rownames(out) <- ind.variables#
    }#
    out.list <- list()#
    out.list[["p.values"]] <- out#
    out.list[["ci"]] <- out.ci#
    if (output.replicates == TRUE) {#
        out.list[["replicates"]] <- rep.store#
    }#
    return(invisible(out.list))#
}
#' @export#
#' Calculate Cluster-Robust p-Values and Confidence Intervals Based on Webb (2013)#
#' @keywords cluster #
#
cluster.webb.plm <- function (mod, dat, cluster, ci.level = 0.95, boot.reps = 1000, #
    report = TRUE, prog.bar = TRUE, output.replicates = FALSE) #
{#
    if (min(class(dat) != "pdata.frame")) {#
        cat("\n", "\n", "Note: auto-converting data to pdata.frame; first two variables MUST be group and time indices.", #
            "\n", "See ?pdata.frame and consider manually converting data to pdata.frame.", #
            "\n", "\n")#
        dat <- pdata.frame(dat, index = colnames(dat)[1:2], row.names = F)#
    }#
    if (cluster == "group") {#
        clust <- attr(mod$mod, "index")[, 1]#
        clust.name <- colnames(attr(mod$mod, "index"))[1]#
        clust.full <- attr(dat, "index")[, 1]#
        used.idx <- which(rownames(dat) %in% rownames(mod$model))#
        G <- length(unique(clust))#
    }#
    if (cluster == "time") {#
        cat("\n", "\n", "Note: create new variable containing lag when clustering on time", #
            "\n")#
        clust <- attr(mod$mod, "index")[, 2]#
        clust.name <- colnames(attr(mod$mod, "index"))[2]#
        clust.full <- attr(dat, "index")[, 2]#
        used.idx <- which(rownames(dat) %in% rownames(mod$model))#
        G <- length(unique(clust))#
    }#
    if (cluster != "group" & cluster != "time") {#
        stop("invalid clustering variable; see help file")#
    }#
    form <- mod$formula#
    variables <- all.vars(form)#
    ind.variables <- names(coefficients(mod))#
    ind.variables.data <- all.vars(update(form, 1 ~ .))#
    se.clust <- sqrt(diag(vcovHC(mod, cluster = cluster)))#
    beta.mod <- coefficients(mod)[ind.variables]#
    w <- beta.mod/se.clust#
    dat$dv.new[used.idx] <- mod$model[, 1]#
    form.new <- update(form, dv.new ~ .)#
    if (prog.bar == TRUE) {#
        cat("Wild Cluster bootstrapping w/o imposing null...", #
            "\n")#
    }#
    boot.dat <- dat#
    w.store <- matrix(data = NA, nrow = boot.reps, ncol = length(ind.variables))#
    rep.store <- matrix(data = NA, nrow = boot.reps, ncol = length(beta.mod))#
    colnames(rep.store) <- ind.variables#
    resid <- residuals(mod)#
    if (prog.bar == TRUE) {#
        pb <- txtProgressBar(min = 0, max = boot.reps, initial = 0, #
            style = 3)#
    }#
    for (i in 1:boot.reps) {#
        if (prog.bar == TRUE) {#
            setTxtProgressBar(pb, value = i)#
        }#
        weight <- sample(c(-sqrt(1.5), -1, -sqrt(0.5), sqrt(0.5), 1, sqrt(1.5)),  #
            size = G, replace = T, prob = rep(1/6, 6))[match(clust, unique(clust))]#
        pseudo.resid <- resid * weight#
        pseudo.dv <- predict(mod) + pseudo.resid#
        boot.dat[used.idx, "dv.new"] <- pseudo.dv#
        boot.mod.call <- mod$call#
        boot.mod.call[[2]] <- quote(form.new)#
        boot.mod.call[[3]] <- quote(boot.dat)#
        boot.mod <- suppressWarnings(tryCatch(eval(boot.mod.call), #
            error = function(e) {#
                return(NA)#
            }))#
        se.boot <- sqrt(diag(vcovHC(boot.mod, cluster = cluster)))#
        beta.boot <- coefficients(boot.mod)[ind.variables]#
        w.store[i, ] <- (beta.boot - beta.mod)/se.boot#
        rep.store[i, ] <- beta.boot#
    }#
    if (prog.bar == TRUE) {#
        close(pb)#
    }#
    comp.fun <- function(vec2, vec1) {#
        as.numeric(vec1 > vec2)#
    }#
    if (length(ind.variables) == 1) {#
        p.store.s <- matrix(as.double(abs(w)) > as.double(abs(w.store)), #
            ncol = 1)#
        crit.t <- quantile(abs(w.store), ci.level)#
    }#
    else {#
        p.store.s <- t(apply(X = abs(w.store), FUN = comp.fun, #
            MARGIN = 1, vec1 = abs(w)))#
        crit.t <- apply(X = abs(w.store), MARGIN = 2, FUN = quantile, #
            probs = ci.level)#
    }#
    p.store <- 1 - (colSums(p.store.s)/boot.reps)#
    ci.lo <- beta.mod - crit.t * se.clust#
    ci.hi <- beta.mod + crit.t * se.clust#
    print.ci <- cbind(ind.variables, ci.lo, ci.hi)#
    print.ci <- rbind(c("variable name", "CI lower", "CI higher"), #
        print.ci)#
    out.ci <- cbind(ci.lo, ci.hi)#
    rownames(out.ci) <- ind.variables#
    colnames(out.ci) <- c("CI lower", "CI higher")#
    out <- matrix(p.store, ncol = 1)#
    colnames(out) <- c("wild cluster BS p-value")#
    rownames(out) <- ind.variables#
    }#
    out.list <- list()#
    out.list[["p.values"]] <- out#
    out.list[["ci"]] <- out.ci#
    if (output.replicates == TRUE) {#
        out.list[["replicates"]] <- rep.store#
    }#
    return(invisible(out.list))#
}
#' @export#
#' Calculate Cluster-Robust p-Values and Confidence Intervals Based on Webb (2013)#
#' @keywords cluster #
#
cluster.webb.plm <- function (mod, dat, cluster, ci.level = 0.95, boot.reps = 1000, #
    report = TRUE, prog.bar = TRUE, output.replicates = FALSE) #
{#
    if (min(class(dat) != "pdata.frame")) {#
        cat("\n", "\n", "Note: auto-converting data to pdata.frame; first two variables MUST be group and time indices.", #
            "\n", "See ?pdata.frame and consider manually converting data to pdata.frame.", #
            "\n", "\n")#
        dat <- pdata.frame(dat, index = colnames(dat)[1:2], row.names = F)#
    }#
    if (cluster == "group") {#
        clust <- attr(mod$mod, "index")[, 1]#
        clust.name <- colnames(attr(mod$mod, "index"))[1]#
        clust.full <- attr(dat, "index")[, 1]#
        used.idx <- which(rownames(dat) %in% rownames(mod$model))#
        G <- length(unique(clust))#
    }#
    if (cluster == "time") {#
        cat("\n", "\n", "Note: create new variable containing lag when clustering on time", #
            "\n")#
        clust <- attr(mod$mod, "index")[, 2]#
        clust.name <- colnames(attr(mod$mod, "index"))[2]#
        clust.full <- attr(dat, "index")[, 2]#
        used.idx <- which(rownames(dat) %in% rownames(mod$model))#
        G <- length(unique(clust))#
    }#
    if (cluster != "group" & cluster != "time") {#
        stop("invalid clustering variable; see help file")#
    }#
    form <- mod$formula#
    variables <- all.vars(form)#
    ind.variables <- names(coefficients(mod))#
    ind.variables.data <- all.vars(update(form, 1 ~ .))#
    se.clust <- sqrt(diag(vcovHC(mod, cluster = cluster)))#
    beta.mod <- coefficients(mod)[ind.variables]#
    w <- beta.mod/se.clust#
    dat$dv.new[used.idx] <- mod$model[, 1]#
    form.new <- update(form, dv.new ~ .)#
    if (prog.bar == TRUE) {#
        cat("Wild Cluster bootstrapping w/o imposing null...", #
            "\n")#
    }#
    boot.dat <- dat#
    w.store <- matrix(data = NA, nrow = boot.reps, ncol = length(ind.variables))#
    rep.store <- matrix(data = NA, nrow = boot.reps, ncol = length(beta.mod))#
    colnames(rep.store) <- ind.variables#
    resid <- residuals(mod)#
    if (prog.bar == TRUE) {#
        pb <- txtProgressBar(min = 0, max = boot.reps, initial = 0, #
            style = 3)#
    }#
    for (i in 1:boot.reps) {#
        if (prog.bar == TRUE) {#
            setTxtProgressBar(pb, value = i)#
        }#
        weight <- sample(c(-sqrt(1.5), -1, -sqrt(0.5), sqrt(0.5), 1, sqrt(1.5)),  #
            size = G, replace = T, prob = rep(1/6, 6))[match(clust, unique(clust))]#
        pseudo.resid <- resid * weight#
        pseudo.dv <- predict(mod) + pseudo.resid#
        boot.dat[used.idx, "dv.new"] <- pseudo.dv#
        boot.mod.call <- mod$call#
        boot.mod.call[[2]] <- quote(form.new)#
        boot.mod.call[[3]] <- quote(boot.dat)#
        boot.mod <- suppressWarnings(tryCatch(eval(boot.mod.call), #
            error = function(e) {#
                return(NA)#
            }))#
        se.boot <- sqrt(diag(vcovHC(boot.mod, cluster = cluster)))#
        beta.boot <- coefficients(boot.mod)[ind.variables]#
        w.store[i, ] <- (beta.boot - beta.mod)/se.boot#
        rep.store[i, ] <- beta.boot#
    }#
    if (prog.bar == TRUE) {#
        close(pb)#
    }#
    comp.fun <- function(vec2, vec1) {#
        as.numeric(vec1 > vec2)#
    }#
    if (length(ind.variables) == 1) {#
        p.store.s <- matrix(as.double(abs(w)) > as.double(abs(w.store)), #
            ncol = 1)#
        crit.t <- quantile(abs(w.store), ci.level)#
    }#
    else {#
        p.store.s <- t(apply(X = abs(w.store), FUN = comp.fun, #
            MARGIN = 1, vec1 = abs(w)))#
        crit.t <- apply(X = abs(w.store), MARGIN = 2, FUN = quantile, #
            probs = ci.level)#
    }#
    p.store <- 1 - (colSums(p.store.s)/boot.reps)#
    ci.lo <- beta.mod - crit.t * se.clust#
    ci.hi <- beta.mod + crit.t * se.clust#
    print.ci <- cbind(ind.variables, ci.lo, ci.hi)#
    print.ci <- rbind(c("variable name", "CI lower", "CI higher"), #
        print.ci)#
    out.ci <- cbind(ci.lo, ci.hi)#
    rownames(out.ci) <- ind.variables#
    colnames(out.ci) <- c("CI lower", "CI higher")#
    out <- matrix(p.store, ncol = 1)#
    colnames(out) <- c("wild cluster BS p-value")#
    rownames(out) <- ind.variables#
    }#
    out.list <- list()#
    out.list[["p.values"]] <- out#
    out.list[["ci"]] <- out.ci#
    if (output.replicates == TRUE) {#
        out.list[["replicates"]] <- rep.store#
    }#
    return(invisible(out.list))#
}
#' @export#
#' Calculate Cluster-Robust p-Values and Confidence Intervals Based on Webb (2013)#
#' @keywords cluster #
#
cluster.webb.plm <- function (mod, dat, cluster, ci.level = 0.95, boot.reps = 1000, #
    report = TRUE, prog.bar = TRUE, output.replicates = FALSE) #
{#
    if (min(class(dat) != "pdata.frame")) {#
        cat("\n", "\n", "Note: auto-converting data to pdata.frame; first two variables MUST be group and time indices.", #
            "\n", "See ?pdata.frame and consider manually converting data to pdata.frame.", #
            "\n", "\n")#
        dat <- pdata.frame(dat, index = colnames(dat)[1:2], row.names = F)#
    }#
    if (cluster == "group") {#
        clust <- attr(mod$mod, "index")[, 1]#
        clust.name <- colnames(attr(mod$mod, "index"))[1]#
        clust.full <- attr(dat, "index")[, 1]#
        used.idx <- which(rownames(dat) %in% rownames(mod$model))#
        G <- length(unique(clust))#
    }#
    if (cluster == "time") {#
        cat("\n", "\n", "Note: create new variable containing lag when clustering on time", #
            "\n")#
        clust <- attr(mod$mod, "index")[, 2]#
        clust.name <- colnames(attr(mod$mod, "index"))[2]#
        clust.full <- attr(dat, "index")[, 2]#
        used.idx <- which(rownames(dat) %in% rownames(mod$model))#
        G <- length(unique(clust))#
    }#
    if (cluster != "group" & cluster != "time") {#
        stop("invalid clustering variable; see help file")#
    }#
    form <- mod$formula#
    variables <- all.vars(form)#
    ind.variables <- names(coefficients(mod))#
    ind.variables.data <- all.vars(update(form, 1 ~ .))#
    se.clust <- sqrt(diag(vcovHC(mod, cluster = cluster)))#
    beta.mod <- coefficients(mod)[ind.variables]#
    w <- beta.mod/se.clust#
    dat$dv.new[used.idx] <- mod$model[, 1]#
    form.new <- update(form, dv.new ~ .)#
    if (prog.bar == TRUE) {#
        cat("Wild Cluster bootstrapping w/o imposing null...", #
            "\n")#
    }#
    boot.dat <- dat#
    w.store <- matrix(data = NA, nrow = boot.reps, ncol = length(ind.variables))#
    rep.store <- matrix(data = NA, nrow = boot.reps, ncol = length(beta.mod))#
    colnames(rep.store) <- ind.variables#
    resid <- residuals(mod)#
    if (prog.bar == TRUE) {#
        pb <- txtProgressBar(min = 0, max = boot.reps, initial = 0, #
            style = 3)#
    }#
    for (i in 1:boot.reps) {#
        if (prog.bar == TRUE) {#
            setTxtProgressBar(pb, value = i)#
        }#
        weight <- sample(c(-sqrt(1.5), -1, -sqrt(0.5), sqrt(0.5), 1, sqrt(1.5)),  #
            size = G, replace = T, prob = rep(1/6, 6))[match(clust, unique(clust))]#
        pseudo.resid <- resid * weight#
        pseudo.dv <- predict(mod) + pseudo.resid#
        boot.dat[used.idx, "dv.new"] <- pseudo.dv#
        boot.mod.call <- mod$call#
        boot.mod.call[[2]] <- quote(form.new)#
        boot.mod.call[[3]] <- quote(boot.dat)#
        boot.mod <- suppressWarnings(tryCatch(eval(boot.mod.call), #
            error = function(e) {#
                return(NA)#
            }))#
        se.boot <- sqrt(diag(vcovHC(boot.mod, cluster = cluster)))#
        beta.boot <- coefficients(boot.mod)[ind.variables]#
        w.store[i, ] <- (beta.boot - beta.mod)/se.boot#
        rep.store[i, ] <- beta.boot#
    }#
    if (prog.bar == TRUE) {#
        close(pb)#
    }#
    comp.fun <- function(vec2, vec1) {#
        as.numeric(vec1 > vec2)#
    }#
    if (length(ind.variables) == 1) {#
        p.store.s <- matrix(as.double(abs(w)) > as.double(abs(w.store)), #
            ncol = 1)#
        crit.t <- quantile(abs(w.store), ci.level)#
    }#
    else {#
        p.store.s <- t(apply(X = abs(w.store), FUN = comp.fun, #
            MARGIN = 1, vec1 = abs(w)))#
        crit.t <- apply(X = abs(w.store), MARGIN = 2, FUN = quantile, #
            probs = ci.level)#
    }#
    p.store <- 1 - (colSums(p.store.s)/boot.reps)#
    ci.lo <- beta.mod - crit.t * se.clust#
    ci.hi <- beta.mod + crit.t * se.clust#
    print.ci <- cbind(ind.variables, ci.lo, ci.hi)#
    print.ci <- rbind(c("variable name", "CI lower", "CI higher"), #
        print.ci)#
    out.ci <- cbind(ci.lo, ci.hi)#
    rownames(out.ci) <- ind.variables#
    colnames(out.ci) <- c("CI lower", "CI higher")#
    out <- matrix(p.store, ncol = 1)#
    colnames(out) <- c("wild cluster BS p-value")#
    rownames(out) <- ind.variables#
    }#
    out.list <- list()#
    out.list[["p.values"]] <- out#
    out.list[["ci"]] <- out.ci#
    if (output.replicates == TRUE) {#
        out.list[["replicates"]] <- rep.store#
    }#
    return(invisible(out.list))#
}
#' @export#
#' Calculate Cluster-Robust p-Values and Confidence Intervals Based on Webb (2013)#
#' @keywords cluster #
#
cluster.webb.plm <- function (mod, dat, cluster, ci.level = 0.95, boot.reps = 1000, #
    report = TRUE, prog.bar = TRUE, output.replicates = FALSE) #
{#
    if (min(class(dat) != "pdata.frame")) {#
        cat("\n", "\n", "Note: auto-converting data to pdata.frame; first two variables MUST be group and time indices.", #
            "\n", "See ?pdata.frame and consider manually converting data to pdata.frame.", #
            "\n", "\n")#
        dat <- pdata.frame(dat, index = colnames(dat)[1:2], row.names = F)#
    }#
    if (cluster == "group") {#
        clust <- attr(mod$mod, "index")[, 1]#
        clust.name <- colnames(attr(mod$mod, "index"))[1]#
        clust.full <- attr(dat, "index")[, 1]#
        used.idx <- which(rownames(dat) %in% rownames(mod$model))#
        G <- length(unique(clust))#
    }#
    if (cluster == "time") {#
        cat("\n", "\n", "Note: create new variable containing lag when clustering on time", #
            "\n")#
        clust <- attr(mod$mod, "index")[, 2]#
        clust.name <- colnames(attr(mod$mod, "index"))[2]#
        clust.full <- attr(dat, "index")[, 2]#
        used.idx <- which(rownames(dat) %in% rownames(mod$model))#
        G <- length(unique(clust))#
    }#
    if (cluster != "group" & cluster != "time") {#
        stop("invalid clustering variable; see help file")#
    }#
    form <- mod$formula#
    variables <- all.vars(form)#
    ind.variables <- names(coefficients(mod))#
    ind.variables.data <- all.vars(update(form, 1 ~ .))#
    se.clust <- sqrt(diag(vcovHC(mod, cluster = cluster)))#
    beta.mod <- coefficients(mod)[ind.variables]#
    w <- beta.mod/se.clust#
    dat$dv.new[used.idx] <- mod$model[, 1]#
    form.new <- update(form, dv.new ~ .)#
    if (prog.bar == TRUE) {#
        cat("Wild Cluster bootstrapping w/o imposing null...", #
            "\n")#
    }#
    boot.dat <- dat#
    w.store <- matrix(data = NA, nrow = boot.reps, ncol = length(ind.variables))#
    rep.store <- matrix(data = NA, nrow = boot.reps, ncol = length(beta.mod))#
    colnames(rep.store) <- ind.variables#
    resid <- residuals(mod)#
    if (prog.bar == TRUE) {#
        pb <- txtProgressBar(min = 0, max = boot.reps, initial = 0, #
            style = 3)#
    }#
    for (i in 1:boot.reps) {#
        if (prog.bar == TRUE) {#
            setTxtProgressBar(pb, value = i)#
        }#
        weight <- sample(c(-sqrt(1.5), -1, -sqrt(0.5), sqrt(0.5), 1, sqrt(1.5)),  #
            size = G, replace = T, prob = rep(1/6, 6))[match(clust, unique(clust))]#
        pseudo.resid <- resid * weight#
        pseudo.dv <- predict(mod) + pseudo.resid#
        boot.dat[used.idx, "dv.new"] <- pseudo.dv#
        boot.mod.call <- mod$call#
        boot.mod.call[[2]] <- quote(form.new)#
        boot.mod.call[[3]] <- quote(boot.dat)#
        boot.mod <- suppressWarnings(tryCatch(eval(boot.mod.call), #
            error = function(e) {#
                return(NA)#
            }))#
        se.boot <- sqrt(diag(vcovHC(boot.mod, cluster = cluster)))#
        beta.boot <- coefficients(boot.mod)[ind.variables]#
        w.store[i, ] <- (beta.boot - beta.mod)/se.boot#
        rep.store[i, ] <- beta.boot#
    }#
    if (prog.bar == TRUE) {#
        close(pb)#
    }#
    comp.fun <- function(vec2, vec1) {#
        as.numeric(vec1 > vec2)#
    }#
    if (length(ind.variables) == 1) {#
        p.store.s <- matrix(as.double(abs(w)) > as.double(abs(w.store)), #
            ncol = 1)#
        crit.t <- quantile(abs(w.store), ci.level)#
    } else {#
        p.store.s <- t(apply(X = abs(w.store), FUN = comp.fun, #
            MARGIN = 1, vec1 = abs(w)))#
        crit.t <- apply(X = abs(w.store), MARGIN = 2, FUN = quantile, #
            probs = ci.level)#
    }#
    p.store <- 1 - (colSums(p.store.s)/boot.reps)#
    ci.lo <- beta.mod - crit.t * se.clust#
    ci.hi <- beta.mod + crit.t * se.clust#
    print.ci <- cbind(ind.variables, ci.lo, ci.hi)#
    print.ci <- rbind(c("variable name", "CI lower", "CI higher"), #
        print.ci)#
    out.ci <- cbind(ci.lo, ci.hi)#
    rownames(out.ci) <- ind.variables#
    colnames(out.ci) <- c("CI lower", "CI higher")#
    out <- matrix(p.store, ncol = 1)#
    colnames(out) <- c("wild cluster BS p-value")#
    rownames(out) <- ind.variables#
    }#
    out.list <- list()#
    out.list[["p.values"]] <- out#
    out.list[["ci"]] <- out.ci#
    if (output.replicates == TRUE) {#
        out.list[["replicates"]] <- rep.store#
    }#
    return(invisible(out.list))#
}
#' @export#
#' Calculate Cluster-Robust p-Values and Confidence Intervals Based on Webb (2013)#
#' @keywords cluster #
#
cluster.webb.plm <- function (mod, dat, cluster, ci.level = 0.95, boot.reps = 1000, #
    report = TRUE, prog.bar = TRUE, output.replicates = FALSE) #
{#
    if (min(class(dat) != "pdata.frame")) {#
        cat("\n", "\n", "Note: auto-converting data to pdata.frame; first two variables MUST be group and time indices.", #
            "\n", "See ?pdata.frame and consider manually converting data to pdata.frame.", #
            "\n", "\n")#
        dat <- pdata.frame(dat, index = colnames(dat)[1:2], row.names = F)#
    }#
    if (cluster == "group") {#
        clust <- attr(mod$mod, "index")[, 1]#
        clust.name <- colnames(attr(mod$mod, "index"))[1]#
        clust.full <- attr(dat, "index")[, 1]#
        used.idx <- which(rownames(dat) %in% rownames(mod$model))#
        G <- length(unique(clust))#
    }#
    if (cluster == "time") {#
        cat("\n", "\n", "Note: create new variable containing lag when clustering on time", #
            "\n")#
        clust <- attr(mod$mod, "index")[, 2]#
        clust.name <- colnames(attr(mod$mod, "index"))[2]#
        clust.full <- attr(dat, "index")[, 2]#
        used.idx <- which(rownames(dat) %in% rownames(mod$model))#
        G <- length(unique(clust))#
    }#
    if (cluster != "group" & cluster != "time") {#
        stop("invalid clustering variable; see help file")#
    }#
    form <- mod$formula#
    variables <- all.vars(form)#
    ind.variables <- names(coefficients(mod))#
    ind.variables.data <- all.vars(update(form, 1 ~ .))#
    se.clust <- sqrt(diag(vcovHC(mod, cluster = cluster)))#
    beta.mod <- coefficients(mod)[ind.variables]#
    w <- beta.mod/se.clust#
    dat$dv.new[used.idx] <- mod$model[, 1]#
    form.new <- update(form, dv.new ~ .)#
    if (prog.bar == TRUE) {#
        cat("Wild Cluster bootstrapping w/o imposing null...", #
            "\n")#
    }#
    boot.dat <- dat#
    w.store <- matrix(data = NA, nrow = boot.reps, ncol = length(ind.variables))#
    rep.store <- matrix(data = NA, nrow = boot.reps, ncol = length(beta.mod))#
    colnames(rep.store) <- ind.variables#
    resid <- residuals(mod)#
    if (prog.bar == TRUE) {#
        pb <- txtProgressBar(min = 0, max = boot.reps, initial = 0, #
            style = 3)#
    }#
    for (i in 1:boot.reps) {#
        if (prog.bar == TRUE) {#
            setTxtProgressBar(pb, value = i)#
        }#
        weight <- sample(c(-sqrt(1.5), -1, -sqrt(0.5), sqrt(0.5), 1, sqrt(1.5)),  #
            size = G, replace = T, prob = rep(1/6, 6))[match(clust, unique(clust))]#
        pseudo.resid <- resid * weight#
        pseudo.dv <- predict(mod) + pseudo.resid#
        boot.dat[used.idx, "dv.new"] <- pseudo.dv#
        boot.mod.call <- mod$call#
        boot.mod.call[[2]] <- quote(form.new)#
        boot.mod.call[[3]] <- quote(boot.dat)#
        boot.mod <- suppressWarnings(tryCatch(eval(boot.mod.call), #
            error = function(e) {#
                return(NA)#
            }))#
        se.boot <- sqrt(diag(vcovHC(boot.mod, cluster = cluster)))#
        beta.boot <- coefficients(boot.mod)[ind.variables]#
        w.store[i, ] <- (beta.boot - beta.mod)/se.boot#
        rep.store[i, ] <- beta.boot#
    }#
    if (prog.bar == TRUE) {#
        close(pb)#
    }#
    comp.fun <- function(vec2, vec1) {#
        as.numeric(vec1 > vec2)#
    }#
    if (length(ind.variables) == 1) {#
        p.store.s <- matrix(as.double(abs(w)) > as.double(abs(w.store)), #
            ncol = 1)#
        crit.t <- quantile(abs(w.store), ci.level)#
    } else {#
        p.store.s <- t(apply(X = abs(w.store), FUN = comp.fun, #
            MARGIN = 1, vec1 = abs(w)))#
        crit.t <- apply(X = abs(w.store), MARGIN = 2, FUN = quantile, #
            probs = ci.level)#
    }#
    p.store <- 1 - (colSums(p.store.s)/boot.reps)#
    ci.lo <- beta.mod - crit.t * se.clust#
    ci.hi <- beta.mod + crit.t * se.clust#
    print.ci <- cbind(ind.variables, ci.lo, ci.hi)#
    print.ci <- rbind(c("variable name", "CI lower", "CI higher"), #
        print.ci)#
    out.ci <- cbind(ci.lo, ci.hi)#
    rownames(out.ci) <- ind.variables#
    colnames(out.ci) <- c("CI lower", "CI higher")#
    out <- matrix(p.store, ncol = 1)#
    colnames(out) <- c("wild cluster BS p-value")#
    rownames(out) <- ind.variables#
    out.list <- list()#
    out.list[["p.values"]] <- out#
    out.list[["ci"]] <- out.ci#
    if (output.replicates == TRUE) {#
        out.list[["replicates"]] <- rep.store#
    }#
    return(invisible(out.list))#
}
document()
#' @export#
#' Calculate Cluster-Robust p-Values and Confidence Intervals Based on Webb (2013)#
#' @keywords cluster #
#
cluster.webb.ivreg <- function (mod, dat, cluster, vars.boot = NULL, ci.level = 0.95, impose.null = TRUE, boot.reps = 1000, report = TRUE, prog.bar = TRUE, output.replicates = FALSE) #
{#
    if (output.replicates == TRUE & impose.null == TRUE) {#
        stop("Recovering bootstrap replicates requires setting impose.null = FALSE")#
    }#
    form <- mod$formula#
    variables <- all.vars(form)#
    clust.name <- all.vars(cluster)#
    used.idx <- which(rownames(dat) %in% rownames(mod$model))#
    dat <- dat[used.idx, ]#
    clust <- as.vector(unlist(dat[[clust.name]]))#
    G <- length(unique(clust))#
    "%w/o%" <- function(x, y) x[!x %in% y]#
    ind.variables <- names(mod$coefficients) %w/o% "(Intercept)"#
    dv <- variables %w/o% all.vars(update(form, 1 ~ .))#
    ind.variables.data <- all.vars(update(form, 1 ~ .))#
    ind.variables.names <- names(coefficients(mod))#
    dat$dv.new <- mod$y#
    form.new <- update(as.Formula(form), dv.new ~ .)#
    fac <- c()#
    for (i in 1:length(ind.variables.data)) {#
        fac[i] <- is.factor(dat[, ind.variables.data[i]])#
    }#
    fac <- max(fac)#
    if (fac == 1 & impose.null == TRUE) {#
        cat("\n", "\n", "Note: null not imposed (factor variables are present).", #
            "\n")#
        impose.null <- FALSE#
    }#
    cl <- function(dat, fm, cluster) {#
        M <- length(unique(cluster))#
        N <- length(cluster)#
        K <- fm$rank#
        dfc <- (M/(M - 1))#
        uj <- apply(estfun(fm), 2, function(x) tapply(x, cluster, #
            sum))#
        vcovCL <- dfc * sandwich(fm, meat. = crossprod(uj)/N)#
        coeftest(fm, vcovCL)#
    }#
    se.clust <- cl(dat, mod, clust)[ind.variables.names, 2]#
    beta.mod <- coefficients(mod)[ind.variables.names]#
    w <- beta.mod/se.clust#
    if (!is.null(vars.boot)){#
    	ind.variables.boot <- match(vars.boot, ind.variables)#
    	} else {#
		ind.variables.boot <- 1:length(ind.variables)		#
	 }#
    if (impose.null == TRUE) {#
        p.store <- c()#
        w.store <- matrix(data = NA, nrow = boot.reps, ncol = length(ind.variables))#
        if (names(mod$coefficients)[1] == "(Intercept)") {#
            offset <- 1#
        }#
        else {#
            offset <- 0#
        }#
        if (prog.bar == TRUE) {#
            cat("\n")#
        }#
        for (j in ind.variables.boot)) {#
            if (prog.bar == TRUE) {#
                cat("Independent variable being bootstrapped: ", #
                  ind.variables[j], "\n")#
            }#
            mod.form <- as.Formula(mod$form)#
            form.null <- update(mod.form, as.formula(paste("~ . -", #
                ind.variables[j], "| . -", ind.variables[j])))#
            mod.call <- mod$call#
            mod.call[[2]] <- form.null#
            mod.call[[3]] <- quote(dat)#
            mod.null <- eval(mod.call)#
            null.resid <- residuals(mod.null)#
            boot.dat <- dat#
            wald.store <- c()#
            if (prog.bar == TRUE) {#
                pb <- txtProgressBar(min = 0, max = boot.reps, #
                  initial = 0, style = 3)#
            }#
            for (i in 1:boot.reps) {#
                if (prog.bar == TRUE) {#
                  setTxtProgressBar(pb, value = i)#
                }#
                weight <- sample(c(-sqrt(1.5), -1, -sqrt(0.5), sqrt(0.5), 1, sqrt(1.5)),  #
                    size = G, replace = T, prob = rep(1/6, 6))[match(clust, unique(clust))]#
                pseudo.resid <- null.resid * weight#
                pseudo.dv <- predict(mod.null) + pseudo.resid#
                boot.dat[, "dv.new"] <- pseudo.dv#
                boot.mod.call <- mod$call#
                boot.mod.call[[2]] <- quote(form.new)#
                boot.mod.call[[3]] <- quote(boot.dat)#
                boot.mod <- suppressWarnings(tryCatch(eval(boot.mod.call), #
                  error = function(e) {#
                    return(NA)#
                  }))#
                se.boot <- cl(boot.dat, boot.mod, clust)[offset + #
                  j, 2]#
                beta.boot <- coefficients(boot.mod)[offset + #
                  j]#
                wald.store[i] <- beta.boot/se.boot#
            }#
            if (prog.bar == TRUE) {#
                close(pb)#
            }#
            p.store[j] <- 1 - (sum(abs(w[offset + j]) > abs(wald.store))/boot.reps)#
            w.store[, j] <- wald.store#
        }#
        p.store <- p.store[ind.variables.boot]#
        w.store <- w.store[ ,ind.variables.boot]#
        out <- matrix(p.store, ncol = 1)#
        colnames(out) <- c("wild cluster BS p-value")#
        rownames(out) <- vars.boot#
        ci.lo = NULL#
        ci.hi = NULL#
        print.ci = NULL#
        out.ci = NULL#
    } else {#
        if (prog.bar == TRUE) {#
            cat("Wild Cluster bootstrapping w/o imposing null...", #
                "\n")#
        }#
        boot.dat <- dat#
        w.store <- matrix(data = NA, nrow = boot.reps, ncol = length(ind.variables.names))#
        rep.store <- matrix(data = NA, nrow = boot.reps, ncol = length(beta.mod))#
        colnames(rep.store) <- ind.variables.names#
        resid <- residuals(mod)#
        if (prog.bar == TRUE) {#
            pb <- txtProgressBar(min = 0, max = boot.reps, initial = 0, #
                style = 3)#
        }#
        for (i in 1:boot.reps) {#
            if (prog.bar == TRUE) {#
                setTxtProgressBar(pb, value = i)#
            }#
            weight <- sample(c(-sqrt(1.5), -1, -sqrt(0.5), sqrt(0.5), 1, sqrt(1.5)),  #
                size = G, replace = T, prob = rep(1/6, 6))[match(clust, unique(clust))]#
            pseudo.resid <- resid * weight#
            pseudo.dv <- predict(mod) + pseudo.resid#
            boot.dat[, "dv.new"] <- pseudo.dv#
            boot.mod.call <- mod$call#
            boot.mod.call[[2]] <- quote(form.new)#
            boot.mod.call[[3]] <- quote(boot.dat)#
            boot.mod <- suppressWarnings(tryCatch(eval(boot.mod.call), #
                error = function(e) {#
                  return(NA)#
                }))#
            se.boot <- cl(boot.dat, boot.mod, clust)[, 2]#
            beta.boot <- coefficients(boot.mod)#
            w.store[i, ] <- (beta.boot - beta.mod)/se.boot#
            rep.store[i, ] <- beta.boot#
        }#
        if (prog.bar == TRUE) {#
            close(pb)#
        }#
        comp.fun <- function(vec2, vec1) {#
            as.numeric(vec1 > vec2)#
        }#
        p.store.s <- t(apply(X = abs(w.store), FUN = comp.fun, #
            MARGIN = 1, vec1 = abs(w)))#
        p.store <- 1 - (colSums(p.store.s)/dim(w.store)[1])#
        crit.t <- apply(X = abs(w.store), MARGIN = 2, FUN = quantile, #
            probs = ci.level)#
        ci.lo <- beta.mod - crit.t * se.clust#
        ci.hi <- beta.mod + crit.t * se.clust#
        print.ci <- cbind(ind.variables.names, ci.lo, ci.hi)#
        print.ci <- rbind(c("variable name", "CI lower", "CI higher"), #
            print.ci)#
        out.ci <- cbind(ci.lo, ci.hi)#
        rownames(out.ci) <- ind.variables.names#
        colnames(out.ci) <- c("CI lower", "CI higher")#
        out <- matrix(p.store, ncol = 1)#
        colnames(out) <- c("wild cluster BS p-value")#
        rownames(out) <- ind.variables.names#
#
    }#
    out.list <- list()#
    out.list[["p.values"]] <- out#
    out.list[["ci"]] <- out.ci#
    if (output.replicates == TRUE) {#
        out.list[["replicates"]] <- rep.store#
    }#
    return(invisible(out.list))#
}
#' @export#
#' Calculate Cluster-Robust p-Values and Confidence Intervals Based on Webb (2013)#
#' @keywords cluster #
#
cluster.webb.ivreg <- function (mod, dat, cluster, vars.boot = NULL, ci.level = 0.95, impose.null = TRUE, boot.reps = 1000, report = TRUE, prog.bar = TRUE, output.replicates = FALSE) #
{#
    if (output.replicates == TRUE & impose.null == TRUE) {#
        stop("Recovering bootstrap replicates requires setting impose.null = FALSE")#
    }#
    form <- mod$formula#
    variables <- all.vars(form)#
    clust.name <- all.vars(cluster)#
    used.idx <- which(rownames(dat) %in% rownames(mod$model))#
    dat <- dat[used.idx, ]#
    clust <- as.vector(unlist(dat[[clust.name]]))#
    G <- length(unique(clust))#
    "%w/o%" <- function(x, y) x[!x %in% y]#
    ind.variables <- names(mod$coefficients) %w/o% "(Intercept)"#
    dv <- variables %w/o% all.vars(update(form, 1 ~ .))#
    ind.variables.data <- all.vars(update(form, 1 ~ .))#
    ind.variables.names <- names(coefficients(mod))#
    dat$dv.new <- mod$y#
    form.new <- update(as.Formula(form), dv.new ~ .)#
    fac <- c()#
    for (i in 1:length(ind.variables.data)) {#
        fac[i] <- is.factor(dat[, ind.variables.data[i]])#
    }#
    fac <- max(fac)#
    if (fac == 1 & impose.null == TRUE) {#
        cat("\n", "\n", "Note: null not imposed (factor variables are present).", #
            "\n")#
        impose.null <- FALSE#
    }#
    cl <- function(dat, fm, cluster) {#
        M <- length(unique(cluster))#
        N <- length(cluster)#
        K <- fm$rank#
        dfc <- (M/(M - 1))#
        uj <- apply(estfun(fm), 2, function(x) tapply(x, cluster, #
            sum))#
        vcovCL <- dfc * sandwich(fm, meat. = crossprod(uj)/N)#
        coeftest(fm, vcovCL)#
    }#
    se.clust <- cl(dat, mod, clust)[ind.variables.names, 2]#
    beta.mod <- coefficients(mod)[ind.variables.names]#
    w <- beta.mod/se.clust#
    if (!is.null(vars.boot)){#
    	ind.variables.boot <- match(vars.boot, ind.variables)#
    	} else {#
		ind.variables.boot <- 1:length(ind.variables)		#
	 }#
    if (impose.null == TRUE) {#
        p.store <- c()#
        w.store <- matrix(data = NA, nrow = boot.reps, ncol = length(ind.variables))#
        if (names(mod$coefficients)[1] == "(Intercept)") {#
            offset <- 1#
        }#
        else {#
            offset <- 0#
        }#
        if (prog.bar == TRUE) {#
            cat("\n")#
        }#
        for (j in ind.variables.boot) {#
            if (prog.bar == TRUE) {#
                cat("Independent variable being bootstrapped: ", #
                  ind.variables[j], "\n")#
            }#
            mod.form <- as.Formula(mod$form)#
            form.null <- update(mod.form, as.formula(paste("~ . -", #
                ind.variables[j], "| . -", ind.variables[j])))#
            mod.call <- mod$call#
            mod.call[[2]] <- form.null#
            mod.call[[3]] <- quote(dat)#
            mod.null <- eval(mod.call)#
            null.resid <- residuals(mod.null)#
            boot.dat <- dat#
            wald.store <- c()#
            if (prog.bar == TRUE) {#
                pb <- txtProgressBar(min = 0, max = boot.reps, #
                  initial = 0, style = 3)#
            }#
            for (i in 1:boot.reps) {#
                if (prog.bar == TRUE) {#
                  setTxtProgressBar(pb, value = i)#
                }#
                weight <- sample(c(-sqrt(1.5), -1, -sqrt(0.5), sqrt(0.5), 1, sqrt(1.5)),  #
                    size = G, replace = T, prob = rep(1/6, 6))[match(clust, unique(clust))]#
                pseudo.resid <- null.resid * weight#
                pseudo.dv <- predict(mod.null) + pseudo.resid#
                boot.dat[, "dv.new"] <- pseudo.dv#
                boot.mod.call <- mod$call#
                boot.mod.call[[2]] <- quote(form.new)#
                boot.mod.call[[3]] <- quote(boot.dat)#
                boot.mod <- suppressWarnings(tryCatch(eval(boot.mod.call), #
                  error = function(e) {#
                    return(NA)#
                  }))#
                se.boot <- cl(boot.dat, boot.mod, clust)[offset + #
                  j, 2]#
                beta.boot <- coefficients(boot.mod)[offset + #
                  j]#
                wald.store[i] <- beta.boot/se.boot#
            }#
            if (prog.bar == TRUE) {#
                close(pb)#
            }#
            p.store[j] <- 1 - (sum(abs(w[offset + j]) > abs(wald.store))/boot.reps)#
            w.store[, j] <- wald.store#
        }#
        p.store <- p.store[ind.variables.boot]#
        w.store <- w.store[ ,ind.variables.boot]#
        out <- matrix(p.store, ncol = 1)#
        colnames(out) <- c("wild cluster BS p-value")#
        rownames(out) <- vars.boot#
        ci.lo = NULL#
        ci.hi = NULL#
        print.ci = NULL#
        out.ci = NULL#
    } else {#
        if (prog.bar == TRUE) {#
            cat("Wild Cluster bootstrapping w/o imposing null...", #
                "\n")#
        }#
        boot.dat <- dat#
        w.store <- matrix(data = NA, nrow = boot.reps, ncol = length(ind.variables.names))#
        rep.store <- matrix(data = NA, nrow = boot.reps, ncol = length(beta.mod))#
        colnames(rep.store) <- ind.variables.names#
        resid <- residuals(mod)#
        if (prog.bar == TRUE) {#
            pb <- txtProgressBar(min = 0, max = boot.reps, initial = 0, #
                style = 3)#
        }#
        for (i in 1:boot.reps) {#
            if (prog.bar == TRUE) {#
                setTxtProgressBar(pb, value = i)#
            }#
            weight <- sample(c(-sqrt(1.5), -1, -sqrt(0.5), sqrt(0.5), 1, sqrt(1.5)),  #
                size = G, replace = T, prob = rep(1/6, 6))[match(clust, unique(clust))]#
            pseudo.resid <- resid * weight#
            pseudo.dv <- predict(mod) + pseudo.resid#
            boot.dat[, "dv.new"] <- pseudo.dv#
            boot.mod.call <- mod$call#
            boot.mod.call[[2]] <- quote(form.new)#
            boot.mod.call[[3]] <- quote(boot.dat)#
            boot.mod <- suppressWarnings(tryCatch(eval(boot.mod.call), #
                error = function(e) {#
                  return(NA)#
                }))#
            se.boot <- cl(boot.dat, boot.mod, clust)[, 2]#
            beta.boot <- coefficients(boot.mod)#
            w.store[i, ] <- (beta.boot - beta.mod)/se.boot#
            rep.store[i, ] <- beta.boot#
        }#
        if (prog.bar == TRUE) {#
            close(pb)#
        }#
        comp.fun <- function(vec2, vec1) {#
            as.numeric(vec1 > vec2)#
        }#
        p.store.s <- t(apply(X = abs(w.store), FUN = comp.fun, #
            MARGIN = 1, vec1 = abs(w)))#
        p.store <- 1 - (colSums(p.store.s)/dim(w.store)[1])#
        crit.t <- apply(X = abs(w.store), MARGIN = 2, FUN = quantile, #
            probs = ci.level)#
        ci.lo <- beta.mod - crit.t * se.clust#
        ci.hi <- beta.mod + crit.t * se.clust#
        print.ci <- cbind(ind.variables.names, ci.lo, ci.hi)#
        print.ci <- rbind(c("variable name", "CI lower", "CI higher"), #
            print.ci)#
        out.ci <- cbind(ci.lo, ci.hi)#
        rownames(out.ci) <- ind.variables.names#
        colnames(out.ci) <- c("CI lower", "CI higher")#
        out <- matrix(p.store, ncol = 1)#
        colnames(out) <- c("wild cluster BS p-value")#
        rownames(out) <- ind.variables.names#
#
    }#
    out.list <- list()#
    out.list[["p.values"]] <- out#
    out.list[["ci"]] <- out.ci#
    if (output.replicates == TRUE) {#
        out.list[["replicates"]] <- rep.store#
    }#
    return(invisible(out.list))#
}
document()
setwd("~/my.pkg/")
document()
cluster.wild.glm
library("clusterSEs")
cluster.wild.glm
setwd("~/my.pkg/")
check()
check()
check()
check()
check()
ls()
rm(list = ls())
ls()
install.characters("ipred")
install.packages("ipred")
library("ipred")
errorest
cv
conversion_data <- read.csv("~/Downloads/conversion_data.csv")
logit.model <- glm( converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country) ,family = binomial(link = "logit"), data = conversion_data)
e <- errorest(converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country), data = conversion_data, model = logit.model, estimator = "cv")
logit.model <- glm( converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country), data = conversion_data, family = binomial(link = "logit"))
e <- errorest(converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country), data = conversion_data, model = logit.model, estimator = "cv")
e <- errorest(converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country), data = conversion_data, model = glm, estimator = "cv")
e <- errorest(converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country), data = conversion_data, estimator = "cv")
e <- errorest(converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country), data = conversion_data,model = lm, estimator = "cv")
e <- errorest(converted ,converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country), data = conversion_data,model = logit.model, k= 5, predict = NULL)
e <- errorest(conersion_data$converted ,converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country), data = conversion_data,model = logit.model, k= 5, predict = NULL)
e <- errorest(conversion_data$converted ,converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country), data = conversion_data,model = logit.model, k= 5, predict = NULL)
e <- errorest(conversion_data$converted, formula = converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country), data = conversion_data, model = logit.model, k= 5, predict = NULL)
e <- errorest(conversion_data$converted, formula = converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country), data = conversion_data, model = logit.model, k= 5, predict = NULL)
e <- errorest(conversion_data$converted, formula = converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country), data = conversion_data, model = logit.model, predict = NULL)
logit.model <- function(formula, data){#
glm(formula, data = data, family = binomial(link = "logit"))#
# from coefficients, looks like source of information is not so important in determining conversion#
}
e <- errorest(conversion_data$converted, formula = converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country), data = conversion_data, model = logit.model, k = 5, predict = NULL)
e <- errorest(conversion_data$converted, formula = converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country), data = conversion_data, model = logit.model, predict = NULL)
e <- cv(conversion_data$converted, formula = converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country), data = conversion_data, model = logit.model, predict = NULL)
str(e)
e
e <- cv(conversion_data$converted, formula = converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country), data = conversion_data, k = 3, model = logit.model, predict = conversion_data$converted)
e
e <- cv(conversion_data$converted, formula = converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country), data = conversion_data, k = 3, model = logit.model, predict = NULL)
e
logit.model(formula = converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country), data = conversion_data)
str(logit.model(formula = converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country), data = conversion_data))
logit.model(formula = converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country), data = conversion_data)$Coefficients
logit.coefficients <- logit.model(formula = converted ~ age + factor(source) + factor(new_user) + total_pages_visited + factor(country), data = conversion_data)$coefficients
logit.coefficients
str(logit.coefficients)
X <- conversion_data[, -c("converted")]
X <- conversion_data[, -"converted"]
X <- conversion_data[, -c(6)]
head(X, 2)
colnames(conversion_data)
colnames(conversion_data) == "converted"
nrow(colnames(conversion_data) == "converted")
1:ncol(conversion_data)(colnames(conversion_data) == "converted")
1:ncol(conversion_data)[colnames(conversion_data) == "converted"]
ncol(conversion_data)
(1:ncol(conversion_data))[colnames(conversion_data) == "converted"]
X <- conversion_data[, -c((1:ncol(conversion_data))[colnames(conversion_data) == "converted"])]
head(X, 1)
yhat <- X'*logit.coefficients'
yhat <- t(X)*t(logit.coefficients)
logit.coefficients
as.numeric(logit.coefficients)
yhat <- t(X)*t(as.numeric(logit.coefficients))
yhat <- t(X)%*%t(as.numeric(logit.coefficients))
yhat <- t(as.matrix(X)%*%t(as.numeric(logit.coefficients))
yhat <- t(as.matrix(X))%*%t(as.numeric(logit.coefficients))
Q <- as.matrix(X)
head(Q)
head(as.factor(conversion_data$country))
Q <- as.numeric(levels(conversion_data$country))
head(Q, 15)
range(Q)
Q <- as.numeric(levels(conversion_data$country))[conversion_data$country]
mm <- model.matrix(~country -1, conversion_data)
dim(mm)
head(mm)
mm <- model.matrix(~country, conversion_data)
head(mm)
m <- sapply(c("country", "new_user") , function(x) model.matrix(~x, conversion_data))
m <- sapply(country , function(x) model.matrix(~x, conversion_data))
m <- sapply(conversion_data$country , function(x) model.matrix(~x, conversion_data))
str(m)
formula
formula(~x)
formula(x)
formula(~"convert")
m <- sapply(country , function(x) model.matrix(formula(~x), conversion_data))
m <- sapply(fornula(~country) , function(x) model.matrix(x, conversion_data))
m <- sapply(formula(~country) , function(x) model.matrix(x, conversion_data))
setwd("~/my.pkg/")
check()
check()
create("fewClusterSEs")
detach("roxygen2")
detach(roxygen2)
setwd("fewClusterSEs")
checks()
check()
remove.packages("roxygen2")
check()
check()
library("roxygen2")
library("devtools")
setwd("~/fewClusterSEs/")
check()
library("as.formula")
install.packages("as.formula")
check()
as.formula("y~x")
check()
check()
check()
check()
check()
check()
check()
check()
check()
check()
check()
check()
check()
install("fewClusterSEs")
install("~/fewClusterSEs")
install("~/fewClusterSEs")
check()
install("~/fewClusterSEs")
install("~/fewClusterSEs")
check()
check()
check()
check()
check()
getwwd()
getwd()
document()
